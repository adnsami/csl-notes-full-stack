
check jwt token generated by firebase with firebase admin.

```bash
require('crypto').randomBytes(64).toString('hex')
```

cookie parser
http only cookie

```js

app.use(cors({
	origin: ['https://localhost:5000'],
	credentials: true
}));


res.cookie('token', token, {
hhtpOnly: true,
secure: false,
sameSite: 'none',
}).send({success: true});
```


1. TanStack Query : https://tanstack.com/query/latest/docs/framework/react/overview 
2. React Hook Form : https://react-hook-form.com/ 
3. Ant Design : https://ant.design/docs/react/introduce 
4. Shadcn/ui : https://ui.shadcn.com/docs 
5. NestJS : https://docs.nestjs.com/ 
6. Prisma : https://www.prisma.io/ 


Generates A Token:
![[Pasted image 20241218082749.png]]



Request With Token:
![[Pasted image 20241218082806.png]]

J: JSON
W: WEB
T: TOKEN

header (meta data).payload.signature (hashed string)

rule of thumb: request + token

what is base 64 encode?

base64 encode versus base64 url encode?
The problem with Base64 is that it contains the characters +, /, and =, which have a reserved meaning in some filesystem names and URLs. So base64url solves this by replacing + with - and / with _.


why base64 url encode is done for jwt?
	not for security purpose
	for simplicity
	the data could be large
	easier to handle a plain text
	
what is encoding?
encoding versus encryption

! do not store sensitive data in the payload. put public information

invalidating jwt token if leaked:
- black list token
- for each request, check the token against this blacklist before processing.
- deleting jwt cookie doesn't mean invalidating! other who will have access to it, will able to login. invalidating means black listing the token. so it can't be used anymore. for instance: on logout invalidate the token.
- if refresh token expires, it means you are logged out. you have to login again.
- on logout or if compromised, blacklist both token.


access token : 5 - 15 mins
refresh token 7 - 30 days (or even longer)

## Making Your OWN Signature

```bash
npm i base64url
```

```js
// generate.js

import base64UrlEncode from 'base64url';

import { HMACSHA256 } from './algo.js';

const header = {
    alg: 'HS256',
    typ: 'JWT',
};

const payload = {
    id: 10,
    name: 'Mr. Sami',
    iat: 1734491809315,
};

const data = `${base64UrlEncode(JSON.stringify(header))}.${base64UrlEncode(
    JSON.stringify(payload)
)}`;

const signature = HMACSHA256(data, 'efd5f9e7dbbb0e9a8e478977c4f');

const token = `${data}.${signature}`;

console.log({
    data,
    token,
});

```

```js
// verify.js
import { HMACSHA256 } from './algo.js';

const token =
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwibmFtZSI6Ik1yLiBTYW1pIiwiaWF0IjoxNzM0NDkxODA5MzE1fQ.x2vL-tUgrUS_W1Dw5NIepmuSrAgZ_JHj8MjBwzbxq6s';

const data = `${token.split('.')[0]}.${token.split('.')[1]}`;
const signature = token.split('.')[2];

const newSignature = HMACSHA256(data, 'efd5f9e7dbbb0e9a8e478977c4f');

if (signature === newSignature) {
    console.log('✔️');
} else {
    console.log('❌');
}

```

```hmac.js
import crypto from 'crypto';

export function HMACSHA256(data, SECRET_KEY) {
    const hmac = crypto.createHmac('SHA256', SECRET_KEY);
    hmac.update(data);
    const signature = hmac.digest('base64url');
    return signature;
}

```

## JWT Server Side

```bash
npm i jsonwebtoken
```

protect this api!
```
http://localhost:3000/products
```

login -> if valid user -> generate token

```js
import express from 'express';
import cors from 'cors';
import { MongoClient, ServerApiVersion } from 'mongodb';
import jwt from 'jsonwebtoken';
import cookieParser from 'cookie-parser';

const app = express();
const port = 3000; // entry point of server

const connectionString =
    'mongodb+srv://samicse1:uagIHiuRB0wfz2rD@cluster1.ucfsb.mongodb.net/?retryWrites=true&w=majority&appName=Cluster1';

const client = new MongoClient(connectionString, {
    serverApi: {
        version: ServerApiVersion.v1,
        strict: true,
        deprecationErrors: true,
    },
});

// user defined middleware
const validateToken = async (req, res, next) => {
    console.log('Hit');
    const token = req.cookies?.token;
    if (!token) {
        return res.send({ status: 401 });
    }

    jwt.verify(token, 'SECRET_KEY', (err, decoded) => {
        if (err) {
            return res.send({ status: 401 });
        }
        console.log('verification', decoded);
        // send extra info to next middleware
        req.user = decoded;
        next();
    });
};

async function run() {
    try {
        await client.connect();

        app.post('/generateToken', (req, res) => {
            const payload = req.body;
            console.log('cookies', JSON.stringify(req.cookies));
            console.log(payload);
            // prettier-ignore
            jwt.sign(payload, 'SECRET_KEY', { algorithm: 'HS256', expiresIn: '1d' }, (err, token) => {
                console.log(err)
                res.cookie('token', token, {
                    httpOnly: true,
                    secure: false, // https 
                }).send({success: true});
            });
        });

        app.get('/products', validateToken, async (req, res) => {
            console.log('from products api', req.cookies.token);

            // manage role here or

            try {
                const database = client.db('ecomdb');
                const products = database.collection('products');

                const result = await products.find().toArray();

                res.send(result);
            } catch (error) {
                console.log(error);
            }
        });

        app.post('/products', async (req, res) => {
            try {
                const database = client.db('ecomdb');
                const products = database.collection('products');

                const product = {
                    title: req.body.title,
                    price: Number(req.body.price),
                };

                const id = await products.insertOne(product);
                /*
                 "id": {
                    "acknowledged": true,
                    "insertedId": "67605c815364806796582aec"
                }
                
                */
                res.send(product);
            } catch (error) {
                console.log(error);
            }
        });
    } catch (error) {
        console.log(error);
    }
}
app.use(
    cors({
        origin: ['http://localhost:5173'],
        credentials: true,
    })
);

app.use(express.json());
app.use(cookieParser());

run();

app.listen(port, () => {
    console.log('server is running at port:', port);
});

```

! Tokens have some claims to indicate when they are issued and when they expire (`iat` and `exp`). When these claims change, the signature changes.

## Client Side

```js
npm i axios
```

```js
   useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, (loggedInUser) => {
            console.log('i am observing ...', loggedInUser);
            setUser(loggedInUser);

            if (loggedInUser) {
                const { uid, email } = loggedInUser;
                const payload = { uid, email };
                axios
                    .post(
                        'http://localhost:3000/generateToken',

                        payload,
                        {
                            withCredentials: true,
                        }
                    )
                    .then((res) => console.log(res))
                    .catch((err) => console.log(err));
            }

            setLoading(false);
        });

        return () => {
            unsubscribe();
        };
    }, []);
```

```
npm i cookie-parser
```


case:
- no token provided
- token provided but invalid
- token provided but body's payload is changed
